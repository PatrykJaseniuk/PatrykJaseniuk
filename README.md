
## O mnie 👨‍💻  
  Witam, nazywam się Patryk, lubię władać komputerami za pomocą ![TypeScript](https://img.shields.io/badge/typescript-%23007ACC.svg?style=for-the-badge&logo=typescript&logoColor=white), ![React](https://img.shields.io/badge/react-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB)
. Aktualnie koncentruję się na pisaniu aplikacji webowych w szczególności interfejsów użytkownika. Chciałbym dołączyć do zespołu programistów i napisać coś ładnego i użytecznego.  

## Projekty 📁
###  [Symulator Statków Żaglowych](https://patrykjaseniuk.github.io/StatkiTSDocs/) 
<!-- typescript, nextjs, jest -->
![TypeScript](https://img.shields.io/badge/typescript-%23007ACC.svg?style=for-the-badge&logo=typescript&logoColor=white)
![Next JS](https://img.shields.io/badge/Next-black?style=for-the-badge&logo=next.js&logoColor=white)
![Jest](https://img.shields.io/badge/-jest-%23C21325?style=for-the-badge&logo=jest&logoColor=white)


Symulator/Gra 2D napisana w TypeScript. Użytkownik za pomocą myszki zmienia parametry żagli i steru aby kontrolować statek. Symulator prezentuję esencję działania żaglowca. Można ostrzyć, odpadać, robić zwrot przez rufę, sztag, płynąć z wiatrem, a pod wiatr tylko halsować. Cały statek jest zbudowany z molekuł, które są połączone za pomocą "sprężyn"(soft body dynamics).



### [Strona Siłowni Parys](https://github.com/PatrykJaseniuk/ParysWeb) 
<!-- mantine,typescript, nextjs, react,  storybook -->
[![Mantine](https://img.shields.io/badge/-mantine-%23FFFFFF?style=for-the-badge&logo=mantine&logoColor=black)](https://mantine.dev/)
![TypeScript](https://img.shields.io/badge/typescript-%23007ACC.svg?style=for-the-badge&logo=typescript&logoColor=white)
![Next JS](https://img.shields.io/badge/Next-black?style=for-the-badge&logo=next.js&logoColor=white)
![React](https://img.shields.io/badge/react-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB)
![Storybook](https://img.shields.io/badge/storybook-%23FF4785.svg?style=for-the-badge&logo=storybook&logoColor=white)


Strona reklamowa siłowni Parys w Nysie.
## Umiejętności 💪  

### Języki programowania 💻 
 ![TypeScript](https://img.shields.io/badge/typescript-%23007ACC.svg?style=for-the-badge&logo=typescript&logoColor=white)
![C++](https://img.shields.io/badge/c++-%2300599C.svg?style=for-the-badge&logo=c%2B%2B&logoColor=white) 
![Java](https://img.shields.io/badge/java-%23ED8B00.svg?style=for-the-badge&logo=openjdk&logoColor=white)
![C#](https://img.shields.io/badge/c%23-%23239120.svg?style=for-the-badge&logo=c-sharp&logoColor=white)
![Python](https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54) 
![PHP](https://img.shields.io/badge/php-%23777BB4.svg?style=for-the-badge&logo=php&logoColor=white)

- **TypeScript**  -Aktualnie mój ulubiony język programowania. Cenię w aplikacjach pisanych w TS/JS łatwość uruchomiania na wielu urządzeniach (wystarczy przeglądarka internetowa, lub node). Unikam JS ze wzgledu na brak typowania. Staram się pisać kod w stylu funkcyjnym(korzystać tylko ze stałych), ponieważ jest łatwiejszy w zrozumieniu(brak efektów ubocznych funkcji). 
- **C/C++**  - Pierwszy język, który poznałem. Lubiłem za pomocą niego programować do czasu kiedy np. zobaczyłem jak wygodnie można posługiwać się funkcjami w TS/JS (obywatele pierwszej klasy). C++ daję więcej kontroli (brak garbage collector).
- **Java** - Drugi język który poznałem, rozwinąłem za pomocą niego koncepcję programowania obiektowego.
- **C#** - Podobny do Javy. 
- **Python** -Korzystałem z niego nie zbyt dużo podczas programowania Raspberry Pi. podobny do JS (brak typowania🙁, funkcje obywatelami pierwszej klasy😊), nie przypadło mi do gustu zastąpienie nawiasów klamrowych tabulacją. 
- **PHP** - nie przepadam.


### Frameworki/ biblioteki 📚
![React](https://img.shields.io/badge/react-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB)
![Next JS](https://img.shields.io/badge/Next-black?style=for-the-badge&logo=next.js&logoColor=white)
![Jest](https://img.shields.io/badge/-jest-%23C21325?style=for-the-badge&logo=jest&logoColor=white)

- **React** - Po poznaniu React, polubiłem tworzenie interfejsów użytkownika.
- **NextJS** - Wygodny framework/narzędzie do budowania aplikacji TS+React.
- **Jest** - Staram się pokryć jak najwięcej kodu testami.

### Narzędzia 🛠
![Git](https://img.shields.io/badge/git-%23F05033.svg?style=for-the-badge&logo=git&logoColor=white)
![Visual Studio Code](https://img.shields.io/badge/Visual%20Studio%20Code-0078d7.svg?style=for-the-badge&logo=visual-studio-code&logoColor=white)
![Linux Mint](https://img.shields.io/badge/Linux%20Mint-87CF3E?style=for-the-badge&logo=Linux%20Mint&logoColor=white)

- **Git** - Używam do kontroli wersji projektów, które piszę samodzielnie. Dla każdej nowej funkcjonalności tworzę nową gałąź i po zakończeniu pracy nad nią łączę ją z gałęzią główną. Staram się nazywać commit-y zgodnie z `conventional commits`.
- **Visual Studio Code** - Jest to moje ulubione IDE. Cenię jego prostotę i uniwersalność (ogromną ilość dodatków). 
- **Linux** - System operacyjny o otwartym kodzie źródłowym daje znacznie większą kontrolę nad sprzętem.

### Języki naturalne 🌐 
- **Angielski** - B2.
- **Polski** - Ojczysty.

## Styl programowania 📝

### Nazewnictwo
Piszę długie nazwy czasami składające się z kilku słów, unikam skrótów. Przykład: `CollidingTriangle`, `FluidInteraction`

### Czytelność kodu
Podczas pisania kodu używam dużo stałych pośrednich zamiast wywoływania funkcji w funkcji. Jeżeli jestem w stanie nazwać jakiś fragment kodu(co on robi) wyodrębniam go do funkcji. Staram się nie komentować kodu, nazwy definiowane w kodzie(stałych, funkcji, interfejsów itd.) mają być wystarczające do zrozumienia.

```typescript
    //❌
    const result = doSomething(doSomethingElse(doSomethingElseAgain(doSomethingAgain())));

    //✅
    const somethingAgain = doSomethingAgain();
    const somethingElseAgain = doSomethingElseAgain(somethingAgain);
    const somethingElse = doSomethingElse(somethingElseAgain);
    const result = doSomething(somethingElse);
```

### Programowanie funkcyjne 
Staram się pisać funkcyjnie tzn nie korzystać ze zmiennych danych (`let` `var`), tylko **stałych** (`const`). Takie założenie powoduje, że korzystanie z elementów języka z blokiem o odrębnej przestrzeni nazw (np. `for`, `if`, `switch case`) jest bezcelowe, ponieważ, każda nazwa tam zdefiniowana jest niedostępna poza tym blokiem. Ponadto funkcje zawsze zwracają wartość, inaczej nie maja sensu.
#### Przykłady:
##### blok warunkowy `if`

```typescript
    import {doSomething, doSomethingElse, getCondition} from 'something';

    //imperatywnie:
    let result1;
    if(getCondition()){
        result1 = doSomething();
    }else{
        result1 = doSomethingElse();
    }

    //funkcyjne:
    const result2 = getCondition() ? doSomething() : doSomethingElse();
```

##### blok warunkowy `switch case`

```typescript
    import {doSomething1, doSomething2, doSomething3, getWariant} from 'something';

    //imperatywnie:
    let result1;
    switch(getWariant()){
        case 1:
            result1 = doSomething1();
            break;
        case 2:
            result1 = doSomething2();
            break;
        case 3:
            result1 = doSomething3();
            break;
    }

    //funkcyjne:
    const doSomething = {
        1: doSomething1,
        2: doSomething2,
        3: doSomething3
    }
    const result2 = doSomething[getWariant()]();
```

##### pętla `for`

```typescript
    import {getArray} from 'something';

    //imperatywnie:
    const array = getArray();
    let result1 = [];
    for(let i = 0; i < array.length; i++){
        result1.push(array[i] * 2);
    }

    //funkcyjne:
    const result2 = getArray().map((element) => element * 2);
```

##### pętla `while`

```typescript
    import {doSomething, checkCondition} from 'something';

    //imeratywnie:

    let result1 = doSomething(0);
    while(checkCondition(result1)){
        result1 = doSomething(result1);
    }


    // to już fanatyzm
    //funkcyjne1 rekurencyjnie:
    const doSomethingRecursively = (result) => checkCondition(result) ? doSomethingRecursively(doSomething(result)) : result;
    const result2 = doSomethingRecursively(doSomething(0));

    //funkcyjne2 z wykorzystaniem setTimeout (nie blokuje wątku,nie powoduje stack overflow, wolniejsze):
    const doSomethingSetTimeOut = (result) => checkCondition(result) ? setTimeout(() => doSomethingSetTimeOut(doSomething(result))) : result;
    const result3 = doSomethingSetTimeOut(doSomething(0));
```